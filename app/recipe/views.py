""" Views for the recipe APIs"""

from drf_spectacular.utils import (
    extend_schema_view,
    extend_schema,
    OpenApiParameter,
    OpenApiTypes,
)
from rest_framework import viewsets, mixins, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework import authentication
from rest_framework import permissions

from recipe import serializers
from core import models

"""We are using the extend schema view which is the decorator that allows us to extend the auto generated schema that is generated by the DRF spectacular."""


@extend_schema_view(
    list=extend_schema(  # we are extending the list endpoint for the schema.
        parameters=[
            OpenApiParameter(
                "tags",
                # OpenApiTypes.STR,
                description="Comma separated list of tags IDs to filter",
            ),
            OpenApiParameter(
                "ingredients",
                # OpenApiParameter.STR,
                description="Comma separated list of ingredient IDs to filter ",
            ),
        ]
    )
)
class RecipeViewSet(viewsets.ModelViewSet):
    """View for managing Recipe API"""

    serializer_class = serializers.RecipeDetailSerializer
    queryset = models.Recipe.objects.all()
    authentication_classes = [authentication.TokenAuthentication]
    permission_classes = [permissions.IsAuthenticated]
    # authentication_classes = (authentication.TokenAuthentication,)
    # permissions_classes = (permissions.IsAuthenticated,)

    # Override our get_queryset method, so we can filter the recipe to the authenticated user only. The get_queryset is the object that is returned to go fetch recipes from our database.

    def _params_to_ints(self, qs):
        """Converts command separated list of strings to integer"""
        # tag = 1,2,3
        return [int(str_id) for str_id in qs.split(",")]

    def get_queryset(self):
        """Override the default queryset to fetch recipe for the authenticated user."""
        """Retrieve recipes for authenticated user"""
        tags = self.request.query_params.get("tags")  # retrieving the query params
        ingredients = self.request.query_params.get(
            "ingredients"
        )  # retrieving the query params
        queryset = (
            self.queryset
        )  # we declare our queryset so we can apply filters as we go and then return the queryset
        if tags:
            tag_ids = self._params_to_ints(
                tags
            )  # if there are tags, we first pass it through our method to convert it from comma separated tags to actual lists.
            queryset = queryset.filter(
                tags__id__in=tag_ids
            )  # this is how you can filter unrelated fields in a database using django
        if ingredients:
            ingredient_ids = self._params_to_ints(ingredients)
            queryset = queryset.filter(ingredients__id__in=ingredient_ids)
        # We are filtering by filters we have been filtering by: self.queryset
        return (
            queryset.filter(user=self.request.user).order_by("-id").distinct()
        )  # we need to make it distinct because we could have multiple tags or ingredients added to the same recipe.

        # return self.queryset.filter(user=self.request.user)
        # recipes = self.queryset.filter(user=self.request.user).order_by("-id")
        # return recipes

    # DRF Own Way of knowing the model to work with based on the action.
    # Override the method and do somethings here.
    def get_serializer_class(self):
        """Return the serializer class for request."""
        if self.action == "list":
            return serializers.RecipeSerializer
        # actions are ways of adding additional functionalities ontop of the default functionality on the django modelviewset
        elif self.action == "upload_image":
            return serializers.RecipeImageSerializer
        return self.serializer_class

    def perform_create(self, serializer):
        """Create a new recipe. This perform create is used to override the behaviour for when DRF saves a model for a viewset"""

        serializer.save(user=self.request.user)

    @action(methods=["POST"], detail=True, url_path="upload-image")
    def upload_image(self, request, pk=None):
        """Upload an image to recipe"""
        recipe = self.get_object()
        serializer = self.get_serializer(recipe, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class BaseRecipeAttrViewSet(
    mixins.DestroyModelMixin,
    mixins.UpdateModelMixin,
    mixins.ListModelMixin,
    viewsets.GenericViewSet,
):
    """Base viewset for recipe attributes."""

    authentication_classes = (authentication.TokenAuthentication,)
    permission_classes = (permissions.IsAuthenticated,)

    def get_queryset(self):
        """Filter queryset to authenticated user"""
        return self.queryset.filter(user=self.request.user).order_by("-name")


class TagViewSet(BaseRecipeAttrViewSet):
    """Manage tags in the database"""

    serializer_class = serializers.TagSerializer
    queryset = models.Tag.objects.all()

    # def get_queryset(self):
    #     """Filter queryset to authenticated user"""
    #     return self.queryset.filter(user=self.request.user).order_by("-name")


class IngredientViewSet(BaseRecipeAttrViewSet):
    """Manage Ingredients in the database."""

    serializer_class = serializers.IngredientSerializer
    queryset = models.Ingredient.objects.all()

    # def get_queryset(self):
    #     """Filter queryset to authenticated user"""
    #     return self.queryset.filter(user=self.request.user).order_by("-name")
